---
title: '퀵 정렬 알고리즘 시각화'
date: '2023-12-15'
---

<QuickSortProvider initialArray={[50, 25, 90, 10, 35, 80, 60, 15]}>

# 퀵 정렬 알고리즘 시각화

퀵 정렬(Quick Sort)은 분할 정복(Divide and Conquer) 전략을 사용하는 효율적인 정렬 알고리즘입니다. 평균 시간 복잡도가 $O(n \log n)$이며, 실제로 가장 빠른 정렬 알고리즘 중 하나로 알려져 있습니다.

이 포스트에서는 단계별로 인터랙티브 시각화를 통해 퀵 정렬의 동작 원리를 깊이 이해해보겠습니다. **각 단계에서 선택한 배열과 피벗이 다음 단계로 이어집니다.**

## 1단계: 피벗 선택 이해하기

퀵 정렬의 첫 번째 단계는 **피벗(Pivot)**을 선택하는 것입니다. 피벗은 배열을 두 부분으로 나누는 기준점 역할을 합니다.

### 피벗 선택의 중요성

피벗 선택 방법에 따라 알고리즘의 성능이 달라질 수 있습니다:

- **최선**: 피벗이 항상 중간값을 선택 → $O(n \log n)$
- **최악**: 피벗이 항상 최소/최대값을 선택 → $O(n^2)$

### 직접 선택해보기

아래 배열에서 피벗을 선택해보세요. 각 요소를 클릭하면 해당 요소가 피벗으로 선택됩니다.

<PivotSelector />

일반적으로는 **마지막 요소**를 피벗으로 선택하는 것이 구현이 간단하고 효율적입니다. 위의 "표준 방법" 버튼을 눌러 확인해보세요.

## 2단계: 분할(Partition) 과정 이해하기

피벗을 선택한 후, 이제 **분할(Partition)** 과정을 통해 배열을 재배치합니다.

### 분할의 목표

피벗을 기준으로:
- 피벗보다 **작은** 요소들은 피벗의 **왼쪽**으로
- 피벗보다 **큰** 요소들은 피벗의 **오른쪽**으로

이렇게 배치하면 피벗은 최종적으로 올바른 위치에 있게 됩니다.

### 단계별 분할 과정

아래 시각화를 통해 분할이 어떻게 진행되는지 단계별로 확인해보세요:

<PartitionVisualizer />

**관찰 포인트:**
- 각 단계에서 어떤 요소가 피벗과 비교되는지
- 언제 교환이 일어나는지
- 최종적으로 피벗이 어디에 위치하는지

## 3단계: 재귀적 정렬 이해하기

분할이 완료되면, 피벗을 기준으로 나뉜 **두 부분 배열**에 대해 동일한 과정을 재귀적으로 수행합니다.

### 재귀 호출 구조

$$
\text{quickSort}(A, \text{low}, \text{high}) = \begin{cases}
\text{partition} + \text{quickSort}(\text{왼쪽}) + \text{quickSort}(\text{오른쪽}) & \text{if } \text{low} < \text{high} \\
\text{종료} & \text{otherwise}
\end{cases}
$$

### 전체 과정 시각화

이제 전체 정렬 과정을 처음부터 끝까지 확인해보세요:

<QuickSortVisualizer />

이 시각화에서는:
- **노란색**: 현재 피벗
- **파란색**: 비교 중인 요소
- **빨간색**: 교환되는 요소
- **초록색**: 정렬 완료된 요소

## 알고리즘의 시간 복잡도

### 최선의 경우
- **$O(n \log n)$**: 피벗이 항상 배열의 중간값을 선택하는 경우

### 평균의 경우
- **$O(n \log n)$**: 대부분의 경우

### 최악의 경우
- **$O(n^2)$**: 피벗이 항상 최소값 또는 최대값을 선택하는 경우 (예: 이미 정렬된 배열)

## 공간 복잡도

- **평균**: $O(\log n)$ (재귀 호출 스택)
- **최악**: $O(n)$

## 실제 구현 예시

```javascript
function quickSort(arr, low = 0, high = arr.length - 1) {
  if (low < high) {
    // 분할하고 피벗의 인덱스를 얻음
    const pi = partition(arr, low, high);
    
    // 피벗을 기준으로 왼쪽과 오른쪽을 재귀적으로 정렬
    quickSort(arr, low, pi - 1);
    quickSort(arr, pi + 1, high);
  }
  return arr;
}

function partition(arr, low, high) {
  const pivot = arr[high];
  let i = low - 1;
  
  for (let j = low; j < high; j++) {
    if (arr[j] < pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }
  
  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
  return i + 1;
}
```

## 장점과 단점

### 장점
- 평균적으로 매우 빠른 성능
- 제자리 정렬(In-place sorting) 가능
- 캐시 효율성이 좋음

### 단점
- 최악의 경우 성능이 $O(n^2)$로 저하될 수 있음
- 불안정 정렬(Unstable sort)

## 학습 요약

이 포스트에서 우리는 세 가지 단계의 시각화를 통해 퀵 정렬을 학습했습니다:

1. **피벗 선택**: 어떤 요소를 기준으로 할지 선택
2. **분할 과정**: 피벗을 기준으로 배열을 재배치
3. **전체 정렬**: 재귀적으로 전체 배열을 정렬

각 단계를 직접 체험해보면서 알고리즘의 동작 원리를 깊이 이해할 수 있었을 것입니다.

<InteractivePanel title="추가 학습 자료">
  <div className="space-y-3">
    <p>퀵 정렬을 더 깊이 이해하고 싶다면:</p>
    <ul className="list-disc pl-5 space-y-1 text-sm">
      <li>다양한 피벗 선택 전략 연구 (중간값, 랜덤 등)</li>
      <li>3-way partition을 사용한 개선된 퀵 정렬</li>
      <li>작은 배열에 대한 삽입 정렬 하이브리드 접근</li>
      <li>다른 정렬 알고리즘과의 성능 비교</li>
    </ul>
  </div>
</InteractivePanel>

</QuickSortProvider>
