---
title: 'Command Pattern: 요청을 객체로 캡슐화하기'
date: '2024-01-20'
---

# Command Pattern: 요청을 객체로 캡슐화하기

Command Pattern은 요청을 객체로 캡슐화하여 요청을 매개변수화하고, 큐에 넣거나 로그에 기록하며, 실행 취소(undo) 기능을 지원할 수 있게 해주는 행동 디자인 패턴입니다.

## 왜 Command Pattern이 필요한가?

일반적인 코드에서는 요청을 직접 호출합니다:

```typescript
// 직접 호출 방식
class Light {
  turnOn() {
    console.log('불이 켜졌습니다');
  }
  
  turnOff() {
    console.log('불이 꺼졌습니다');
  }
}

const light = new Light();
light.turnOn();  // 직접 호출
```

하지만 다음과 같은 상황에서는 문제가 발생합니다:

- **실행 취소(Undo) 기능**이 필요할 때
- **요청을 큐에 넣어 나중에 실행**하고 싶을 때
- **요청을 로그에 기록**하고 싶을 때
- **요청을 매개변수화**하여 전달하고 싶을 때

Command Pattern은 이러한 문제를 해결합니다.

## 기본 구조

Command Pattern은 다음과 같은 구성 요소로 이루어집니다:

1. **Command (명령 인터페이스)**: 실행할 작업을 정의하는 인터페이스
2. **ConcreteCommand (구체적인 명령)**: Command 인터페이스를 구현하는 클래스
3. **Receiver (수신자)**: 실제 작업을 수행하는 객체
4. **Invoker (호출자)**: Command를 실행하는 객체
5. **Client (클라이언트)**: Command 객체를 생성하고 Invoker에 전달

## 간단한 예제: 조명 제어

<Section>
  <StickyWrapper side="right">
    <CommandPatternProvider>
      <CommandExecutor />
    </CommandPatternProvider>
  </StickyWrapper>

  <Content>
  가장 기본적인 Command Pattern 예제는 리모컨으로 조명을 제어하는 것입니다.
  
  오른쪽의 인터랙티브 예제를 보세요. **화면 상단에 고정된 리모컨**을 통해 조명을 켜고 끌 수 있습니다. 스크롤을 내려도 리모컨은 계속 따라오므로 언제든 조작할 수 있습니다.
  
  ### 어떻게 동작하나요?
  
  1. **Client**: 사용자가 버튼을 클릭합니다.
  2. **Invoker**: 리모컨(`RemoteControl`)이 명령 객체를 받습니다.
  3. **Command**: `LightOnCommand` 또는 `LightOffCommand` 객체가 생성됩니다.
  4. **Receiver**: 실제 조명(`Light`) 객체의 `turnOn()`/`turnOff()` 메서드가 호출됩니다.
  
  이 과정에서 리모컨은 조명이 어떻게 켜지는지 알 필요가 없습니다. 단지 명령 객체의 `execute()`를 호출할 뿐입니다.
  
  **직접 체험해보세요:**
  - "불 켜기" 버튼을 눌러보세요. 조명이 켜집니다.
  - "불 끄기" 버튼을 눌러보세요. 조명이 꺼집니다.
  - "실행 취소(Undo)" 버튼을 누르면 가장 최근의 명령이 취소됩니다.
  
  코드로 보면 다음과 같습니다:

```typescript
// 1. Command 인터페이스
interface Command {
  execute(): void;
  undo(): void;
}

// 2. Receiver (실제 작업을 수행하는 객체)
class Light {
  turnOn() {
    console.log('불이 켜졌습니다');
  }
  
  turnOff() {
    console.log('불이 꺼졌습니다');
  }
}

// 3. ConcreteCommand (구체적인 명령)
class LightOnCommand implements Command {
  private light: Light;
  
  constructor(light: Light) {
    this.light = light;
  }
  
  execute() {
    this.light.turnOn();
  }
  
  undo() {
    this.light.turnOff();
  }
}
```

  이처럼 요청을 객체로 만들면, 요청을 처리하는 시점을 미루거나, 다른 객체로 전달하거나, **실행 취소**를 구현하기가 매우 쉬워집니다.
  </Content>
</Section>

## 실행 취소 기능과 히스토리

<Section>
  <StickyWrapper side="left">
    <CommandPatternProvider>
      <CommandHistory />
    </CommandPatternProvider>
  </StickyWrapper>

  <Content>
  Command Pattern의 가장 강력한 기능 중 하나는 **실행 취소(Undo)** 및 **히스토리 관리**입니다.
  
  왼쪽의 인터랙티브 컴포넌트는 명령이 실행될 때마다 스택에 쌓이는 모습을 보여줍니다. 텍스트를 읽으면서 왼쪽의 상태 변화를 실시간으로 확인해보세요.
  
  ### 히스토리 관리의 원리
  
  1. 명령을 실행(`execute`)하기 전에, 해당 명령 객체를 **히스토리 스택**에 저장합니다.
  2. 실행 취소(`undo`) 요청이 오면, 스택에서 가장 최근 명령을 꺼냅니다.
  3. 그 명령 객체의 `undo()` 메서드를 호출합니다.
  
  **직접 체험해보세요:**
  - "불 켜기 명령 추가" 버튼을 여러 번 눌러보세요. 리스트에 명령이 쌓입니다.
  - 리스트의 특정 항목을 클릭해보세요. 해당 시점의 상태로 **시간 여행**을 할 수 있습니다.
  - "히스토리 초기화"를 누르면 모든 기록이 사라집니다.
  
  이를 코드로 구현하면 다음과 같습니다:

```typescript
class RemoteControlWithHistory {
  private history: Command[] = [];
  private currentPosition: number = -1;
  
  executeCommand(command: Command) {
    // 현재 위치 이후의 명령들을 제거 (새로운 명령이 실행되면)
    this.history = this.history.slice(0, this.currentPosition + 1);
    
    // 새 명령 실행
    command.execute();
    
    // 히스토리에 추가
    this.history.push(command);
    this.currentPosition++;
  }
  
  undo() {
    if (this.currentPosition >= 0) {
      const command = this.history[this.currentPosition];
      command.undo();
      this.currentPosition--;
    }
  }
}
```

  이 방식은 포토샵의 "히스토리" 기능이나 텍스트 에디터의 `Ctrl+Z` 기능과 동일한 원리입니다. 모든 변경 사항을 Command 객체로 저장해두면, 언제든지 과거의 상태로 돌아갈 수 있습니다.
  </Content>
</Section>

## 매크로 명령 (Macro Command)

여러 명령을 하나의 명령으로 묶어서 실행할 수 있습니다:

```typescript
class MacroCommand implements Command {
  private commands: Command[];
  
  constructor(commands: Command[]) {
    this.commands = commands;
  }
  
  execute() {
    this.commands.forEach(command => command.execute());
  }
  
  undo() {
    // 역순으로 실행 취소
    for (let i = this.commands.length - 1; i >= 0; i--) {
      this.commands[i].undo();
    }
  }
}
```

## 실제 활용 사례

### 1. 텍스트 에디터

텍스트 입력, 삭제, 스타일 변경 등을 모두 Command로 구현하여 실행 취소/다시 실행을 지원합니다.

### 2. 작업 큐 (Job Queue)

비동기 작업을 Command 객체로 만들어 큐에 넣고, 순차적으로 처리하거나 실패 시 재시도할 수 있습니다.

### 3. GUI 버튼 및 메뉴

버튼 클릭 시 수행할 동작을 Command 객체로 주입하여, 버튼 클래스를 수정하지 않고도 동작을 변경할 수 있습니다.

## 요약

Command Pattern은 요청을 객체로 캡슐화하여 다음과 같은 이점을 제공합니다:

1. **실행 취소/다시 실행**: 명령 히스토리를 통해 쉽게 구현 가능
2. **단일 책임 원칙**: 작업을 수행하는 객체와 작업을 요청하는 객체를 분리
3. **개방-폐쇄 원칙**: 기존 코드를 수정하지 않고 새로운 명령을 추가 가능

이 패턴을 통해 유연하고 확장 가능한 애플리케이션을 설계해보세요.
