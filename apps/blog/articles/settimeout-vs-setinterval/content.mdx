---
title: 'setTimeout vs setInterval 심층 분석 — 동작 원리, 타이머 드리프트, Node.js vs 브라우저 고려사항'
description: '자바스크립트 타이머의 내부 동작, 이벤트 루프 스케줄링, 드리프트 발생 원인과 보정 전략, 환경별 구현 차이를 p5.js와 d3.js 시각화로 완벽 이해'
date: '2025-11-21'
author: 'jiwon'
tags: ['JavaScript', 'Event Loop', 'Timers', 'Performance', 'Node.js', 'Browser']
---

# setTimeout과 setInterval 심층 분석: 동작 원리, 타이머 드리프트, Node.js vs 브라우저 고려사항

자바스크립트에서 비동기 작업을 스케줄링하는 가장 기본적인 방법은 `setTimeout`과 `setInterval`입니다. 하지만 이 두 함수는 단순해 보이는 API 뒤에 복잡한 이벤트 루프 메커니즘, 환경별 구현 차이, 그리고 시간 드리프트(drift)라는 미묘한 문제를 숨기고 있습니다. 본 글에서는 타이머의 내부 동작 원리부터 실무에서 마주치는 정밀도 문제, 그리고 Node.js와 주요 브라우저별 차이까지 p5.js와 d3.js 시각화를 통해 직관적으로 설명합니다.

## 1. setTimeout vs setInterval – 내부 동작과 이벤트 루프

### 1.1 타이머는 환경이 제공하는 API

`setTimeout`과 `setInterval`은 자바스크립트 엔진(V8, SpiderMonkey 등)이 아닌 **호스트 환경(host environment)**이 제공하는 타이머 API입니다. 브라우저에서는 DOM의 Window API로, Node.js에서는 타이머 모듈로 구현되어 있으며, 모두 이벤트 루프와 긴밀하게 연동됩니다.

- **setTimeout(fn, delay)**: 지정한 지연시간(`delay` 밀리초) 후 콜백 함수 `fn`을 **한 번만** 실행하고 종료합니다.
- **setInterval(fn, delay)**: 지정한 지연시간마다 콜백 함수 `fn`을 **반복 실행**하며, `clearInterval`로 중지할 때까지 계속됩니다.

### 1.2 이벤트 루프 스케줄링

타이머를 호출하면 환경은 내부적으로 타이머를 등록하고, 지정된 지연시간이 경과하면 콜백을 **이벤트 루프의 태스크 큐(task queue, 매크로태스크 큐)**에 추가합니다. 중요한 점은 **현재 실행 중인 스크립트가 완료된 뒤에야** 타이머 콜백이 시작된다는 것입니다. 따라서 `delay=0`으로 설정해도 즉시 실행되지 않고, 현재 호출 스택이 비워진 후 다음 틱(tick)에서 처리됩니다.

```javascript
console.log('시작');
setTimeout(() => console.log('타이머'), 0);
console.log('끝');

// 출력 순서:
// 시작
// 끝
// 타이머
```

위 예제에서 `setTimeout`의 콜백은 지연시간이 0이지만, 동기 코드(`console.log('끝')`)가 모두 실행된 후에야 실행됩니다.

### 1.3 브라우저 이벤트 루프

브라우저는 태스크 큐에 타이머 콜백을 넣어두었다가, **렌더링 및 다른 이벤트 처리 이후** 콜백을 실행합니다. HTML 표준에 따르면 연속된 타이머 호출에 대한 **최소 지연시간(예: 4ms)**이 적용됩니다. 구체적으로:

- **중첩 타이머 클램핑**: 5회 이상 중첩된 타이머 호출부터는 최소 4ms 지연이 강제됩니다.
- **백그라운드 탭 스로틀링**: 비활성 탭에서는 브라우저별로 1초~1분까지 최소 지연이 늘어납니다. 예를 들어 Chrome은 백그라운드 탭에서 타이머를 최대 1분 주기로 묶어 실행하며, Firefox도 비활성 탭에 1초 이상의 최소 지연을 적용합니다.
- **페이지 로딩 중 지연**: 주요 로딩이 끝날 때까지 타이머 실행이 지연되기도 합니다.

### 1.4 Node.js 이벤트 루프

Node.js는 **libuv** 기반의 자체 이벤트 루프로 타이머를 관리합니다. Node.js 이벤트 루프는 **여러 단계(phase)**로 구성되며, 그 중 **타이머 단계(timers phase)**에서 현재 만료된 타이머들의 콜백을 순차 실행합니다.

Node의 `setTimeout`/`setInterval`은 브라우저와 API는 유사하지만, 내부 구현(libuv의 힙/리스트 기반 타이머 관리 등)이 다릅니다. 타이머가 등록되면 해당 지연이 지난 후 콜백이 큐에 추가되고, 이후 루프의 타이머 단계에서 실행됩니다.

또한 Node는 `Timeout` 객체를 반환하며 `unref()`/`ref()`로 이벤트 루프 유지 여부를 제어할 수 있습니다. 예를 들어 `unref()`를 호출하면 해당 타이머만 남은 경우 프로세스 종료를 허용하여, 백그라운드 작업 관리에 유용합니다.

### 1.5 정리

요약하면:

- `setTimeout`은 한 번만 미래 호출을 예약하고, `setInterval`은 지속적인 호출을 예약합니다.
- 둘 다 이벤트 루프에 의해 비동기 실행되며, 환경에 따라 최소 지연이나 백그라운드 제약 등이 적용됩니다.
- Node.js와 브라우저 모두 싱글 스레드 이벤트 루프를 사용하기 때문에, **현재 실행 중인 작업이 끝나야만** 타이머 콜백이 실행되고 지연 시간이 초과될 수 있습니다.

<EventLoopSimulator />

위 시뮬레이터에서 **"메인 스레드 600ms 블로킹"** 버튼을 눌러보세요. 모든 모드(setInterval, 재귀 setTimeout, 보정된 setTimeout)에서 실제 콜백 실행이 밀리며, 최근 틱의 drift(ms)가 증가하는 것을 확인할 수 있습니다. 보정 모드는 다음 딜레이를 조정해 평균 간격을 맞추려 시도합니다.

## 2. 시간 드리프트 발생 원인과 각 방식의 차이

### 2.1 드리프트(Drift)란?

타이머 **드리프트(drift)**란 이상적인 간격 대비 실제 타이머 실행 시각이 점차 어긋나는 현상을 말합니다. 예를 들어 1초 간격으로 동작시키려던 타이머가 누적 오차로 몇 초 뒤에는 수 밀리초 늦어지는 것이 드리프트입니다.

### 2.2 주요 원인

드리프트는 다음과 같은 원인으로 발생합니다:

#### 2.2.1 이벤트 루프 지연

자바스크립트가 단일 쓰레드로 동작하므로, 이벤트 루프가 바쁘거나 블로킹되면 타이머 콜백 실행이 지연됩니다. 예를 들어 UI 렌더링이나 긴 연산 중에는 타이머가 제때 실행되지 못하고 대기하여, 예정 시간보다 늦게 실행되면서 오차가 발생합니다.

#### 2.2.2 환경 제약

앞서 언급한 브라우저의 최소 지연시간(4ms) 규칙이나 백그라운드 탭 타이머 제한 때문에, 지정한 `delay`보다 더 늦게 콜백이 실행될 수 있습니다. Chrome의 경우 백그라운드 탭에서 타이머를 최대 1분 주기로 묶어 실행하며, Firefox도 비활성 탭에 1초 이상의 최소 지연을 적용합니다. 이러한 정책도 긴 실행에서 드리프트를 키울 수 있습니다.

#### 2.2.3 setTimeout 자체 호출 간 딜레이

`setTimeout`을 재귀적으로 반복하여 일정 주기를 구현하는 경우, 이전 콜백이 끝난 후 다음 호출을 스케줄링하므로 그만큼 지연이 누적될 수 있습니다. 매 주기마다 콜백 실행 시간이나 스케줄링 오버헤드만큼 간격이 늘어나, 이상적인 주기보다 계속 늦어지는 드리프트가 생깁니다.

```javascript
// 재귀 setTimeout 예제
function tick() {
  // 작업 수행 (5ms 소요)
  doWork();
  
  // 다음 실행 예약
  setTimeout(tick, 1000);
}
setTimeout(tick, 1000);
```

위 코드에서 `doWork()`가 5ms 걸린다면, 실제 간격은 1005ms가 되어 점차 늦어집니다.

#### 2.2.4 setInterval의 연속 스케줄링

`setInterval`은 지정한 주기마다 바로 다음 실행을 예약합니다. 이론상 `setInterval`은 매 주기 정확히 한 번씩 실행되므로 드리프트가 없어야 합니다. 하지만 현실적으로는 이전 콜백이 늦게 시작되거나 오래 실행되면, 그 사이 예정되었던 호출 시점이 지나버리기 때문에 결과적으로 지연이 누적됩니다.

일반적인 구현에서 `setInterval`은 **콜백이 실행될 때마다 "현재 시각 기준으로 다음 주기 후"**를 예약하므로, 이전 호출의 지연이 그대로 다음 호출 시각에 반영됩니다.

### 2.3 setTimeout vs setInterval 드리프트 차이

#### setTimeout 반복 (재귀 호출)

매 회 이전 작업이 완료된 후에 다음 실행을 능동적으로 스케줄하기 때문에, 콜백 실행 시간 + 기타 지연만큼 추가로 시간이 붙습니다. 예를 들어 1초 주기로 `setTimeout`을 재귀 호출하고 콜백이 5ms 걸린다면, 이상적 주기 1000ms보다 늘어난 약 1005ms 간격으로 실행되어 점차 늦어집니다.

#### setInterval

환경 구현에 따라 다르지만, 기본적으로 지정한 간격마다 콜백을 실행하려 시도합니다. 브라우저/Node의 기본 구현에서는 콜백이 늦게 시작되었더라도 완료 시점부터 새로 간격을 계산하므로, 사실상 매 회 지연이 누적된 재귀 `setTimeout`과 비슷하게 늦어집니다.

다만 일부 환경(예: Chromium 기반 브라우저)은 **드리프트 보정 알고리즘**을 적용하여, 약간 늦어진 경우 다음 간격을 조금 당겨 실행함으로써 평균 주기를 맞추려 합니다. (자세한 내용은 4장에서 다룹니다)

#### 중첩/지연된 실행의 영향

만약 콜백 함수가 주기보다 오래 걸리거나(예: 1초 인터벌에 1.5초짜리 작업) 이벤트 루프가 바빠 제때 실행하지 못하면, `setInterval`의 경우 해당 주기의 호출이 끝나자마자 즉시 다음 콜백을 실행하거나 연달아 실행되는 현상이 생길 수 있습니다. 즉, 지나간 주기만큼 밀려있던 콜백들을 바로 처리하여 리듬이 깨지거나, 심한 경우 주기를 건너뛰는 일도 발생합니다.

### 2.4 드리프트 예시

Node.js나 보정 없는 브라우저에서 1초 간격 `setInterval`을 10회 실행하면, 매 회 약 1ms씩 추가 지연되어 10초 경과 시 약 10~16ms 정도 늦어집니다. 실제로 한 개발자가 Firefox에서 실행한 결과:

```javascript
let start = Date.now();
let count = 0;

setInterval(() => {
  count++;
  console.log(`${Date.now() - start}ms`);
}, 1000);

// 출력:
// 1001ms
// 2002ms
// 3003ms
// ...
// 10016ms
```

위 출력처럼 1초마다 출력이 점점 1ms 이상씩 늦어져, 10회째에는 약 16ms 지연 누적이 관찰되었습니다. 이렇듯 미세한 지연이 쌓여 장기적으로는 눈에 띌 정도의 오차로 이어질 수 있습니다.

### 2.5 드리프트 시각화

<IntervalDriftChart />

위 그래프는 각 틱에서의 드리프트(실제 시각 - 기대 시각, ms)를 선으로 보여줍니다. 환경(Chromium/Firefox/Safari/Node), 간격(ms), 틱 수를 조절해보세요.

- **Chromium**: 평균 간격을 맞추려는 보정 경향으로 장기 드리프트가 덜 누적되는 모습을 보입니다.
- **Firefox/Safari/Node**: 누적 드리프트가 꾸준히 증가하는 경향을 보입니다(단, 실행 시간 일부 보정 등 세부 동작은 다를 수 있음).

## 3. 드리프트 방지 및 보정 전략

타이머 드리프트를 완전히 없애기는 어렵지만, 아래와 같은 기법으로 완화하거나 보정할 수 있습니다.

### 3.1 재귀 setTimeout으로 제어

앞서 언급했듯, `setInterval`은 이전 작업이 끝나지 않아도 호출이 쌓일 수 있기 때문에 작업이 길어질 가능성이 있는 경우 **재귀적인 setTimeout**이 권장됩니다. 한 사이클이 끝난 후에 다음 사이클을 예약하면, 중복 실행이나 폭주를 막고 일정한 순서를 유지할 수 있습니다.

```javascript
function doTask() {
  // ... 작업 내용 ...
  setTimeout(doTask, interval);  // 다음 실행 예약
}
setTimeout(doTask, interval);  // 초기 실행 시작
```

위 패턴에서는 이전 작업이 끝난 후에야 다음 타이머를 설정하므로, 동시에 겹쳐 실행되는 것을 방지합니다. 다만 이 방식도 매 회 작업 시간만큼 간격이 지연되므로, 아주 정밀한 주기가 필요하다면 추가 보정이 필요합니다.

### 3.2 실제 경과 시간 기반 보정

시스템 시계를 사용하여 이상적 시각 대비 얼마나 늦었는지 계산하고, 다음 지연시간을 조정하는 방식입니다. 예를 들어, 1초 간격 타이머를 구현하면서 매 호출마다 "예정 시각 = 시작시각 + (횟수×1000ms)"를 계산하고 현재 시각과 비교합니다. 그 차이를 drift로 두고, 다음 `setTimeout`을 `1000ms - drift`로 설정하면 누적 지연을 상쇄할 수 있습니다.

```javascript
const interval = 1000;
const startTime = Date.now();
let count = 0;

function tick() {
  count++;
  const expected = startTime + count * interval;
  const now = Date.now();
  const drift = now - expected;
  
  // ... (콜백 작업 실행) ...
  
  const nextDelay = Math.max(interval - drift, 0);
  setTimeout(tick, nextDelay);
}

setTimeout(tick, interval);
```

위 코드에서는 매 `tick`마다 **현재 시각(now)**에서 **기대시각(expected)**을 빼서 드리프트를 구하고, 다음 지연시간을 `(interval - drift)`로 조절합니다. 이렇게 하면 이전 실행이 조금 늦어졌다면 다음 간격을 조금 당겨주어, 평균 주기를 보정합니다.

실제로 한 블로그에서는 이 기법으로 Firefox에서 매 회 1ms씩 늦어지던 것을 보완하여, 타이머가 장시간 실행돼도 일정한 평균 간격을 유지하도록 했습니다.

### 3.3 시스템 시간 재동기화

긴 주기의 타이머에서는 아예 매번 현재 시간을 비교해 절대 시간 기준으로 이벤트를 동기화하기도 합니다. 예를 들어 실제 시계 초에 맞춘 디지털 시계를 구현할 때, 매 1초마다 `new Date()`를 읽어 표시하면 설령 타이머가 늦어져도 화면에는 정확한 시각이 표시됩니다. 즉, 주기마다 시스템 시각으로 보정하여 오차 누적을 방지하는 것입니다.

```javascript
setInterval(() => {
  const now = new Date();
  clockLabel.innerText = now.toLocaleTimeString();
}, 1000);
```

### 3.4 다른 API 활용

#### requestAnimationFrame

애니메이션이나 화면 갱신처럼 프레임 기반 주기가 필요할 경우 `setInterval`보다 **requestAnimationFrame**이 권장됩니다. `requestAnimationFrame`은 브라우저의 리프레시 주기에 맞춰 콜백을 실행하므로, 화면 업데이트 타이밍에 최적화되고 숨겨진 탭에서는 자동으로 중지/저하되어 불필요한 리소스 낭비나 드리프트를 줄여줍니다.

```javascript
function animate() {
  // ... 애니메이션 프레임 렌더링 ...
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
```

단, `requestAnimationFrame`은 화면 주기에 의존하므로 초당 60회 등 고정 간격이 아니며, 논리적 주기 작업에는 맞지 않을 수 있습니다.

#### Web Worker 활용

브라우저에서 메인 스레드가 아닌 Web Worker에서 타이머를 돌리면 메인 스레드 작업에 덜 영향받아 좀 더 안정적일 수 있습니다. 하지만 Worker 역시 결국 브라우저 타이머 규칙(백그라운드 스로틀 등)을 따르고, UI 직접 접근은 안 되므로 상황에 맞게 사용해야 합니다.

### 3.5 정리

이러한 방법들을 상황에 맞게 조합하면 타이머의 드리프트를 크게 완화할 수 있습니다. 예를 들어:

- 네트워크 폴링: 응답 시간만큼 다음 호출을 지연
- UI 시계: 시스템 시간을 참고하여 오차를 보정
- 애니메이션: `requestAnimationFrame` 사용

## 4. Node.js와 주요 브라우저별 타이머 구현 차이

타이머의 동작은 환경마다 미묘한 차이가 있습니다. **정확도(precision)**나 드리프트 보정 전략, 그리고 성능 특성에서 Node.js와 브라우저별로 다음과 같은 차이가 보고됩니다.

### 4.1 Chromium (Chrome, Edge 등)

Chromium 계열 브라우저는 `setInterval`에 **드리프트 보정 로직**을 적용합니다. Chrome에서는 인터벌 실행이 지연되면 다음 간격을 약간 단축하여 원래 주기와 동기화하려고 시도하며, 결코 예정 시각보다 일찍 실행하지는 않습니다.

예를 들어 200ms 주기로 10번 실행 시 Chrome은 이상적인 스케줄(0, 200, 400, …)에 최대한 맞춰 실행하고, 미세한 지연은 다음 주기에 만회합니다. 이 덕분에 평균 간격이 정확히 유지되고 장시간 실행해도 드리프트가 누적되지 않습니다.

실제로 Chrome에서는 1초 타이머를 오래 돌려도 눈에 띄는 오차가 거의 누적되지 않음이 관찰됩니다. 다만 보정 범위에 한계가 있어, **아주 큰 지연(예: 한 주기를 훌쩍 넘는 블로킹)**에는 단지 그 순간에 맞춰 호출을 실행하고 새 리듬으로 이어가는 동작을 보입니다.

### 4.2 Firefox

파이어폭스는 Chrome과 달리 **드리프트 보정이 없는 모델**을 사용합니다. 각 인터벌 콜백을 시작 시각 기준으로 다음 주기를 예약하므로, 콜백 실행이 밀리면 그대로 지연 누적이 계속됩니다.

다만 Firefox는 `setInterval`을 구현할 때 콜백 함수의 실행 시간을 다음 딜레이에서 차감하여, *"콜백이 느리게 실행된 만큼 다음 인터벌을 지연하지 않는다"*는 보정은 합니다. 즉, 함수 자체 실행 시간에 대해서만 부분 보정을 하고, 이벤트 루프 스케줄 지연에 대해서는 보정하지 않는 셈입니다.

그 결과 평균 인터벌은 약간 늘어나며 점차 드리프트가 누적됩니다. 예컨대 100ms 간격 테스트에서 Firefox는 한 사이클도 정확히 100ms를 맞추지 못하고 계속 1ms 이상 늦어졌고, 장시간에는 결국 **주기 하나 정도(예: 1초 타이머가 몇 분 후 1초 이상 차이)**까지 어긋날 수 있습니다.

### 4.3 Safari

Safari(WebKit 기반 브라우저)는 드리프트 보정이 Firefox와 유사하게 제한적입니다. 보고에 따르면 Safari도 콜백 실행 시간 정도만 보정하고, 추가 지연은 누적되는 경향을 보입니다.

다만 드리프트 발생 속도는 Firefox보다 완만해서, 동일 조건에서 Firefox보다 천천히 늦어지는 양상을 보였습니다. 2011년의 한 실험에서는 Safari가 Chrome보다 평균 간격 오차가 작고 Firefox와 비슷하게 양호한 정확도를 보였다는 결과도 있습니다.

즉, Safari는 비교적 안정적이지만 Chrome처럼 능동 보정은 없어 장시간엔 결국 오차가 누적됩니다.

### 4.4 Edge

최신 Edge는 Chromium 기반이므로 Chrome과 동일하게 동작합니다. 이전 구버전 Edge(EdgeHTML 엔진)는 별도 구현이었으나 현재는 Chromium으로 통합되었습니다.

### 4.5 Node.js

Node.js의 `setTimeout`/`setInterval`은 HTML 표준을 따를 필요가 없고 브라우저와 독립적으로 진화했습니다. Node 10.x 기준으로도 `setInterval`은 별도의 드리프트 보정 없이 "실행 시점부터 다음 인터벌 간격"을 재예약하는 방식을 유지합니다.

Node 개발자들도 크롬과 같은 보정 도입을 논의했으나, 스펙 상 Browser와 동작을 맞추기 위해 현재까지는 보정하지 않는 방향입니다. 따라서 Node의 타이머도 이벤트 루프 지연에 따라 드리프트하며, 앞서 예시한 30초에 12ms 오차 등 미세한 누적이 발생합니다.

Node는 브라우저와 달리 탭 비활성 개념은 없지만, CPU 바쁨이나 OS 스케줄링에 따라 지연될 수 있다는 점은 동일합니다. 한편 Node는 타이머 정밀도에 있어서 브라우저보다 일정하게 1ms 단위를 유지하는 경향이 있습니다. 브라우저는 GUI 쓰레드와 병행 작업 등으로 1ms 이내의 jitter가 있을 수 있으나, Node는 서버 부하만 없다면 비교적 안정적으로 동작합니다. (물론 Node도 OS 타이머 해상도 등에 영향을 받습니다.)

### 4.6 기타 차이 – 최소 지연 및 클램핑

브라우저는 중첩 호출 시 4ms 클램프나 백그라운드 타이머 제한 등이 있지만, Node.js에는 그런 인위적 지연 규칙이 없습니다. `setTimeout(fn, 0)`도 Node에선 가능한 빨리(현재 루프 종료 후 즉시) 실행되고, 연쇄 호출 시에도 별도 최소 지연 없이 진행됩니다.

따라서 Node 환경에선 아주 짧은 인터벌 타이머를 만들 수 있지만, 지나치게 빠른 주기는 CPU를 많이 사용하게 되어 주의가 필요합니다. 브라우저에서도 명시적 최소 지연(기본 4ms)이 있으므로, 일반적으로 4ms 이하의 간격은 정확도가 떨어집니다.

### 4.7 정확도와 성능 비교

전반적으로 **Chrome(Chromium)**이 장기 실행 시 평균 주기 정확도가 가장 높고, Firefox/Safari/Node는 소폭씩 느려지는 드리프트가 있습니다. 다만 크롬은 보정 과정에서 **틱 간격의 흔들림(jitter)**이 발생하여, 매 주기가 정확히 일정하기보다는 어떤 때는 약간 빠르고 어떤 때는 약간 느린 형태로 변동폭이 있습니다.

반면 Firefox/Safari/Node는 매 주기가 항상 원래 지연보다 약간 길게 실행되는 안정적인 패턴이라서, 순간적인 변동은 적지만 누적 오차가 생긴다고 볼 수 있습니다.

성능 면에서 Node와 브라우저 모두 타이머 콜백 실행 자체는 가볍지만, 동시 다수의 타이머가 있을 때 관리 비용이 늘어날 수 있습니다. Node는 libuv가 효율적인 자료구조(min-heap 등)로 타이머들을 관리하지만, 수만 개 이상 타이머가 있으면 콜백 실행에 지연이 생길 수 있습니다.

브라우저도 비슷하며, 특히 DOM 업데이트나 렌더링과 겹치면 타이머 처리에 딜레이가 발생합니다. 따라서 과도한 타이머 사용은 지양하고 필요한 경우 타이머 수를 줄이거나 Web Worker, `requestAnimationFrame` 등으로 분산시키는 것이 좋습니다.

## 5. 실무 활용 – 올바른 타이머 사용 예시

다양한 상황별로 `setTimeout`과 `setInterval`을 적절히 선택하고 보조 기법을 활용하면 효율적이고 안전한 코드를 작성할 수 있습니다. 아래에 몇 가지 실무 시나리오와 권장 방식을 정리합니다.

### 5.1 주기적 데이터 폴링 (예: 일정 주기로 서버 API 호출)

**문제**: 서버 응답이 지연되거나 네트워크가 느릴 경우 `setInterval`로 폴링하면 응답이 돌아오기 전에 다음 요청을 보내어 요청이 쌓일 수 있습니다. 이는 불필요한 부하와 응답 순서 뒤엉킴을 초래합니다.

**해결**: **재귀적 setTimeout**을 사용하여 응답 처리 후에 다음 요청을 예약합니다. 이렇게 하면 항상 이전 요청이 완료된 후 다음 호출이 이루어져 서버 부하를 제어할 수 있습니다.

```javascript
function poll() {
  fetch('/api/data')
    .then(processData)
    .finally(() => {
      // 다음 폴링 예약 (예: 5초 후)
      setTimeout(poll, 5000);
    });
}
poll();
```

위 코드에서는 항상 이전 요청이 처리된 후 5초 지연 후에 다음 요청을 보냅니다. 이렇게 하면 네트워크 지연이 있을 때도 요청이 겹치지 않아 안정적인 폴링 주기를 유지할 수 있습니다.

### 5.2 주기적인 UI 업데이트 (예: 실시간 시계/타이머 표시)

**문제**: `setInterval`로 1초마다 시계를 업데이트하면 드리프트로 인해 시간이 지나면서 표시 시각이 실제 시각과 어긋날 수 있습니다. 예를 들어 1시간이 지나면 수백 밀리초 정도 늦게 표시될 수 있습니다. 또한 만약 브라우저 탭이 비활성화됐다 돌아오면 타이머가 뛰는 현상(skip)도 생길 수 있습니다.

**해결**: 시스템 시각에 기반하여 업데이트하고, 필요시 보정합니다. 즉 1초마다 현재 `Date`를 읽어 그 시각을 표시하면, 타이머 드리프트와 무관하게 항상 정확한 시각이 보입니다.

```javascript
setInterval(() => {
  const now = new Date();
  clockLabel.innerText = now.toLocaleTimeString();
}, 1000);
```

이 경우 타이머가 조금 늦게 돌아도 `now`가 실제 현재 시각이므로 표시가 어긋나지 않습니다. 다만 Firefox나 Safari에서는 간혹 1000ms보다 약간 긴 주기로 인해 같은 초가 두 번 표시되거나 (드리프트로 늦어져 skip 발생), Chrome에서는 드물게 한 번 2초 넘겨 건너뛰는 현상이 있을 수 있습니다.

이러한 이슈를 완화하려면 첫 업데이트를 정각(다음 초)가 될 때 맞춰 시작하거나, 드리프트를 감지해 보정하는 로직을 추가할 수 있습니다.

### 5.3 애니메이션 또는 화면 주사율 작업

**권장**: `requestAnimationFrame` 사용. 화면 애니메이션은 60FPS 등 디스플레이 주기에 동기화하는 것이 부드럽고 에너지 효율적입니다. `setInterval(16ms)`으로 60FPS를 구현할 수도 있지만, `requestAnimationFrame`은 화면 리프레시에 맞춰 호출되고, 비가시 상태에서 자동으로 중지되어 CPU 낭비를 줄입니다.

```javascript
function animate() {
  // ... 애니메이션 프레임 렌더링 ...
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
```

이렇게 하면 화면이 활성화된 한 매 프레임 호출이 이루어지고, 프레임 드랍 없이 최적화됩니다. (단, 애니메이션이 아닌 정밀 시간계산에는 `requestAnimationFrame`은 적합하지 않습니다. 예를 들어 1초에 한 번 로그를 찍는 용도로 `requestAnimationFrame`를 쓰면 모니터 주파수나 탭 상태에 따라 호출 간격이 달라질 수 있습니다.)

### 5.4 장시간 대기 후 실행 (예: 1시간 뒤 알람)

**문제**: Node.js나 브라우저 모두 `setTimeout`으로 장시간(수 시간 이상) 타이머를 걸 수 있지만, 만약 애플리케이션이 잠자기 모드에 들어가거나(예: 노트북 절전) 브라우저 탭이 오랫동안 백그라운드에 있다 깨어나면 예정 시간보다 늦게 실행될 수 있습니다.

**권장**: 가능하면 시스템 시간을 함께 확인합니다. 예를 들어 3시간 타이머라면, 3시간 후 현재 시간과 목표 시간을 비교하여 차이가 크면 보정하는 식입니다. 또한 Node.js 환경에서는 주기적으로 현재 시간을 체크하는 별도 인터벌을 운용해 이벤트를 관리하는 것도 방법입니다 (예: 일정 관리 프로그램이라면 매 분 현재 시각을 확인해 알람 시간이 되면 실행).

**참고**: Node.js에서는 `Timeout` 객체의 `refresh()` 메서드를 사용해 남은 시간을 초기화할 수 있습니다. 만약 타이머를 한 번 설정해두고 프로그램이 sleep 했다가 깨는 경우, `refresh()`로 현재 시각 기준 다시 세팅함으로써 지나친 지연을 방지할 수 있습니다.

### 5.5 여러 동시 반복 작업 (예: UI 요소 각각에 인터벌 적용)

**문제**: 많은 `setInterval`이 동시에 돌아가면 각 작업은 작아도 전체 부하가 커질 수 있고, 서로 스케줄 간섭으로 지연이 늘어날 수 있습니다. 또한 참조를 잃어버리면 `clearInterval`을 못 해 메모리 누수가 생길 위험도 있습니다.

**해결**: 가능하면 하나의 인터벌로 여러 작업을 묶어서 처리합니다. 예를 들어 10개의 애니메이션을 각각 100ms 인터벌로 돌리기보다, 하나의 100ms 인터벌에서 10개를 업데이트하는 편이 효율적입니다. 또는 이벤트 기반으로 바꿀 수 있다면 (필요할 때만 타이머 시작/중지) 불필요한 타이머를 제거합니다.

**디버그**: Node.js에서는 `setInterval`이 해제되지 않고 남아있는 경우 프로세스가 종료되지 않는 현상으로 드러날 수 있습니다. 이때 `unref()`를 사용하면 해당 인터벌이 존재해도 프로세스가 종료될 수 있으므로, 백그라운드 주기 작업에 활용하기도 합니다. 하지만 `unref()`된 타이머는 노출되기 어려우므로, 명시적으로 clear하는 것이 바람직합니다.

위의 예시들처럼, 사용 시나리오에 따라 `setTimeout`과 `setInterval`을 적절히 선택하고, 필요하면 보완 기법 (재귀 호출, 시간 보정, `requestAnimationFrame` 등)을 병행하는 것이 중요합니다. 핵심은 **동시 실행 회피**, **오차 누적 관리**, **리소스 낭비 방지** 세 가지로 요약됩니다.

## 6. 고급 개발자를 위한 디버깅 및 성능 분석 기법

타이머 관련 이슈(드리프트, 지연, 메모리 누수 등)를 진단하고 성능을 최적화하기 위해 활용할 수 있는 도구와 기법은 다음과 같습니다.

### 6.1 크롬 개발자 도구 – Performance 프로파일링

브라우저에서는 DevTools의 Performance 패널을 이용해 타이머 동작을 시각화할 수 있습니다. 레코딩을 시작한 후 애플리케이션을 실행하면 "Timer Fired" 등의 이벤트로 각 타이머 콜백의 실행 시점과 지속 시간이 기록됩니다.

이를 통해 인터벌 간격이 일정한지, 특정 주기에 프레임 드랍이나 지연이 발생하는지 확인할 수 있습니다. 또, 긴 주기 작업이 메인 쓰레드를 막아 다른 타이머를 지연시키는지도 타스크 타임라인으로 파악 가능합니다.

DevTools의 시스템 성능 측정(Performance monitor)을 보면 FPS, CPU 사용량, JS 힙 메모리 등이 실시간으로 보여지므로, 타이머를 켰을 때 CPU가 치솟거나 메모리가 증가하면 문제를 인지할 수 있습니다.

### 6.2 Node.js 퍼포먼스 훅(performance hooks)

Node에서는 `perf_hooks` 모듈의 `monitorEventLoopDelay` 기능으로 이벤트 루프 지연 통계를 수집할 수 있습니다. 이를 활용하면 많은 타이머 실행 등으로 이벤트 루프에 **지연(jitter)**이 발생하는지 밀리초 단위로 측정할 수 있습니다.

예를 들어 `performance.monitorEventLoopDelay()`를 사용하면 이벤트 루프가 계획보다 얼마나 지연되었는지의 히스토그램을 얻어, 타이머로 인한 블로킹 여부를 알 수 있습니다. 또한 `console.time()`/`timeEnd()`를 타이머 콜백 내에 배치해 실행 간격을 로깅하면, 실제 주기가 목표와 얼마나 차이나는지 로그로 검출할 수 있습니다.

### 6.3 커스텀 로깅으로 드리프트 추적

간단히는 타이머 콜백마다 `Date.now()` 혹은 `performance.now()` 값을 찍어 간격을 비교하는 방법이 있습니다.

```javascript
let prev = Date.now();
setInterval(() => {
  const now = Date.now();
  console.log(`Interval = ${now - prev} ms`);
  prev = now;
}, 1000);
```

이렇게 하면 콘솔 로그로 매 주기 실제 간격을 출력하여 드리프트 유무를 바로 확인할 수 있습니다. 만약 1000, 1002, 998, 1005… 처럼 변동이 크거나 1000→1001→1002… 식으로 지속 증가하면 드리프트 문제가 있다는 신호입니다.

### 6.4 메모리/레퍼런스 분석

타이머를 사용하다 보면 `clearTimeout`/`clearInterval`을 깜빡하거나, 타이머 콜백 내에서 클로저를 남겨 메모리 누수가 생기는 경우가 있습니다. 브라우저 DevTools의 Memory 분석으로 detached DOM이나 closures를 추적해볼 수 있고, Node.js에서는 `--inspect`로 크롬 DevTools에 연결하여 Heap Snapshot을 찍거나, `process._getActiveHandles()` (비공식)로 현재 활성 타이머 개수를 확인하는 방법도 있습니다. 이를 통해 해제되지 않고 남은 타이머를 발견할 수 있습니다.

### 6.5 프로파일러/플레임그래프

타이머 콜백이 복잡한 연산을 한다면 Node에서는 Clinic.js나 0x 등의 프로파일러로 해당 함수의 CPU 사용을 분석할 수 있습니다. 또는 브라우저 DevTools의 JavaScript Profiler로 특정 인터벌 콜백이 얼마나 오래 걸리는지 파악해 병목을 최적화할 수 있습니다.

예를 들어 100ms 주기의 콜백이 80ms씩 걸린다면 거의 연달아 실행되며 드리프트 및 렉을 유발하므로, 이를 최적화하거나 작업을 분리해야 합니다.

### 6.6 테스트와 모니터링

최종적으로, 중요한 타이머 로직은 테스트를 통한 검증이 필요합니다. 시간 가속 라이브러리(lolex 등)나 가상 타이머를 사용해 단위 테스트를 작성하면 타이머 동작을 재현해볼 수 있습니다.

또한 운영 환경에서는 모니터링을 통해 타이머로 인한 이벤트루프 지연이나 응답 지연을 검출하는 것이 좋습니다. 예를 들어 Node의 프로메테우스 메트릭이나 APM 솔루션으로 이벤트루프 지연(latency)을 추적하면, 타이머 문제를 조기에 발견할 수 있습니다.

고급 개발자라면 위와 같은 도구들을 활용해 타이머 동작을 면밀히 분석하고, 필요하다면 스펙 논의 동향(예: WHATWG 타이머 개선 논의)도 따라가면서 가장 신뢰할 수 있는 구현 패턴을 선택해야 합니다. 타이머는 편리하지만 잘못 사용하면 시간 오차나 성능 문제를 낳을 수 있으므로, 항상 환경별 특성을 고려하고 측정과 검증을 습관화하는 것이 중요합니다.

## 결론

`setTimeout`과 `setInterval`은 자바스크립트에서 가장 기본적인 비동기 스케줄링 도구이지만, 그 이면에는 이벤트 루프, 환경별 구현 차이, 시간 드리프트 등 복잡한 메커니즘이 숨어 있습니다. 본 글에서 살펴본 것처럼:

- 타이머는 호스트 환경이 제공하며, 이벤트 루프를 통해 비동기 실행됩니다.
- 드리프트는 이벤트 루프 지연, 환경 제약, 콜백 실행 시간 등으로 발생하며, 장시간 실행 시 누적될 수 있습니다.
- 재귀 `setTimeout`, 시간 보정, 시스템 시간 동기화, `requestAnimationFrame`, Web Worker 등 다양한 기법으로 드리프트를 완화할 수 있습니다.
- Chromium은 드리프트 보정을 시도하지만, Firefox/Safari/Node는 누적 드리프트가 발생하는 경향이 있습니다.
- 실무에서는 상황에 맞게 타이머를 선택하고, 디버깅 도구로 성능을 분석하며, 테스트와 모니터링으로 검증해야 합니다.

타이머를 올바르게 이해하고 사용하면, 정밀한 시간 제어가 필요한 애플리케이션에서도 안정적이고 효율적인 코드를 작성할 수 있습니다.

---

**참고**: 본 글의 시뮬레이션은 개념적 설명을 위한 근사 모델입니다. 실제 엔진/환경은 버전과 설정에 따라 다르게 동작할 수 있습니다. 주요 원본 자료에서 인용 및 발췌하여 내용을 구성하였으며, 더 자세한 내용은 해당 출처를 참고하시기 바랍니다.


