---
title: 'setTimeout과 setInterval — 차이, 드리프트, 그리고 올바른 사용법에 대한 심층 연구 보고서'
description: 'JavaScript 타이머의 기본 개념부터 내부 동작 메커니즘, 주요 차이점, 심층적인 드리프트 분석 및 해결 전략, 올바른 사용 사례, 그리고 미래 동향까지 포괄적으로 다루는 학술적 연구 보고서'
date: '2025-11-21'
author: 'jiwon'
tags: ['JavaScript', 'Event Loop', 'Timers', 'Performance', 'Node.js', 'Browser', 'Research']
---

# setTimeout과 setInterval — 차이, 드리프트, 그리고 올바른 사용법에 대한 심층 연구 보고서

JavaScript에서 비동기 작업을 처리하는 데 필수적인 `setTimeout`과 `setInterval` 함수는 웹 및 서버 환경에서 널리 사용되지만, 이들의 미묘한 차이, 타이밍 드리프트 현상, 그리고 올바른 사용법을 이해하는 것은 애플리케이션의 성능과 안정성, 보안을 보장하는 데 매우 중요합니다. 이 보고서는 두 타이머 함수의 기본 개념부터 내부 동작 메커니즘, 주요 차이점, 심층적인 드리프트 분석 및 해결 전략, 올바른 사용 사례, 그리고 미래 동향까지 포괄적으로 다룹니다.

## 1. setTimeout과 setInterval의 기본 개념 및 정의

`setTimeout`과 `setInterval`은 JavaScript의 비동기 타이머 기능을 제공하는 핵심 API로, ECMAScript 표준에 정의되어 있으며 브라우저와 Node.js 환경에서 폭넓게 지원됩니다<Footnote>Comparison of the standardization processes of ECMAScript, HTML, and CSS - Aalto University, https://aaltodoc.aalto.fi/items/804e3500-b4ae-4673-b98e-ce7992461772</Footnote>. 이 두 함수는 코드 실행을 지연시키거나 반복하는 데 사용되지만, 그 작동 방식과 의도된 목적에는 근본적인 차이가 있습니다.

### 1.1. setTimeout의 정의 및 작동 원리

`setTimeout`은 지정된 지연 시간(밀리초 단위)이 경과한 후 제공된 콜백 함수를 *단 한 번* 실행하도록 예약합니다<Footnote>Understanding JavaScript event-based interactions - ACM Digital Library, https://dl.acm.org/doi/abs/10.1145/2568225.2568268</Footnote>. 지연 시간이 지나면 콜백은 한 번 호출되고, 그 이후에는 자동으로 실행되지 않습니다. `setTimeout`은 첫 번째 인자로 함수(클로저)를 받거나, 비권장되지만 문자열 형태의 코드를 받아 평가할 수 있습니다. 내부적으로 `setTimeout`은 비동기적으로 동작하며, JavaScript의 이벤트 루프(event loop) 메커니즘을 통해 콜백 실행을 관리합니다. 이 함수는 단발성 이벤트 처리에 적합하며, 특정 조건이 충족될 때까지 기다리거나, 사용자 경험을 위해 의도적인 지연을 주는 상황 등에 활용됩니다.

### 1.2. setInterval의 정의 및 작동 원리

`setInterval`은 지정된 간격(밀리초 단위)마다 제공된 콜백 함수를 *주기적으로 반복 실행*하도록 예약합니다<Footnote>Events and Timers - Springer, https://link.springer.com/chapter/10.1007/978-1-4302-5861-2_4</Footnote>. 초기 지연 후, 콜백 함수는 `clearInterval` 함수를 사용하여 명시적으로 중단될 때까지 대략 지정된 간격으로 반복 호출됩니다. `setInterval` 또한 `setTimeout`과 유사하게 함수 또는 문자열을 콜백 인자로 받을 수 있으며, 비동기적으로 이벤트 루프를 통해 작동합니다. 이 함수는 주기적인 데이터 업데이트, 애니메이션, 실시간 알림 등 반복적인 작업에 주로 사용됩니다.

### 1.3. 타이머 ID 및 취소

`setTimeout`과 `setInterval`은 모두 생성된 타이머를 식별하는 고유한 정수 ID를 반환합니다. 이 ID는 각각 `clearTimeout()`과 `clearInterval()` 함수에 인자로 전달되어 예약된 타이머 실행을 중단시키는 데 사용됩니다<Footnote>Timeouts Best Practices - Office of Scientific and Technical Information, https://www.osti.gov/biblio/2545700</Footnote>. 타이머를 적절히 취소하는 것은 불필요한 리소스 소비와 잠재적인 메모리 누수를 방지하는 데 중요합니다.

## 2. 내부 동작 메커니즘: 이벤트 루프, 콜 스택, 태스크 큐와의 상호작용

JavaScript는 기본적으로 단일 스레드 언어이므로, 비동기 작업을 관리하기 위해 이벤트 루프, 콜 스택(call stack), 태스크 큐(task queue)라는 메커니즘을 활용합니다<Footnote>Reasoning about the node.js event loop using async graphs - IEEE Xplore, https://ieeexplore.ieee.org/abstract/document/8661173/</Footnote>. `setTimeout`과 `setInterval`은 이 복잡한 시스템과 상호작용하며 비동기적으로 작동합니다.

### 2.1. 콜 스택과 이벤트 루프

*   **콜 스택**: 현재 실행 중인 코드 함수 호출을 추적하는 LIFO(Last-In, First-Out) 구조입니다. JavaScript 엔진은 콜 스택에 있는 함수들을 순차적으로 실행하며, 스택이 비어 있을 때만 다른 작업을 처리할 수 있습니다.

*   **이벤트 루프**: 콜 스택과 태스크 큐를 지속적으로 모니터링하는 프로세스입니다<Footnote>The Node Programming Model - Springer, https://link.springer.com/chapter/10.1007/978-1-4302-5861-2_3</Footnote>. 콜 스택이 비어 있을 때, 이벤트 루프는 태스크 큐에서 대기 중인 콜백 함수를 가져와 콜 스택으로 푸시하여 실행을 시작합니다.

### 2.2. 태스크 큐 (콜백 큐)

`setTimeout`과 `setInterval`의 콜백 함수는 지정된 지연 또는 간격이 만료되면 즉시 실행되는 것이 아니라, 태스크 큐(또는 콜백 큐)라는 대기열에 추가됩니다<Footnote>Language support for asynchronous event handling in the invocation call stack - ACM Digital Library, https://dl.acm.org/doi/10.1145/2089131.2089141</Footnote>.

*   **setTimeout의 경우**: 지정된 지연 시간이 경과하면, `setTimeout`의 콜백 함수는 한 번 태스크 큐에 추가됩니다. 이후 이벤트 루프는 콜 스택이 비는 시점에 이 콜백을 꺼내 실행합니다.

*   **setInterval의 경우**: 지정된 간격마다 `setInterval`의 콜백 함수가 태스크 큐에 반복적으로 추가됩니다. 콜백 실행이 늦어지더라도 `setInterval`은 정해진 간격에 따라 다음 콜백을 큐에 추가하려고 시도합니다.

### 2.3. 비동기 동작의 의미

`setTimeout`과 `setInterval`이 비동기적으로 작동한다는 것은, 이들 함수가 콜백을 예약한 후 메인 스레드를 차단하지 않고 즉시 다음 코드를 실행한다는 것을 의미합니다. 콜백 함수 자체는 메인 스레드에서 실행되지만, 스케줄링 및 대기는 백그라운드에서 처리되며 이벤트 루프에 의해 적절한 시점에 실행됩니다<Footnote>Analysis of JavaScript programs: Challenges and research trends - ACM Digital Library, https://dl.acm.org/doi/abs/10.1145/3106741</Footnote>. 따라서 무거운 계산이나 I/O 작업으로 인해 콜 스택이 오랫동안 점유되어 있으면, 태스크 큐에 있는 타이머 콜백들은 콜 스택이 비워질 때까지 기다려야 하므로 실제 실행 시점이 지연될 수 있습니다.

<EventLoopSimulator />

위 시뮬레이터에서 **"메인 스레드 600ms 블로킹"** 버튼을 눌러보세요. 모든 모드(setInterval, 재귀 setTimeout, 보정된 setTimeout)에서 실제 콜백 실행이 밀리며, 최근 틱의 drift(ms)가 증가하는 것을 확인할 수 있습니다. 보정 모드는 다음 딜레이를 조정해 평균 간격을 맞추려 시도합니다.

## 3. 주요 차이점 비교

`setTimeout`과 `setInterval`은 유사해 보이지만, 핵심적인 차이점으로 인해 사용 목적과 적합한 시나리오가 달라집니다<Footnote>Hands-on Node.js - Leanpub, https://dl.ebooksworld.ir/sooth3r/javascript/Leanpub.Hands-on.Node.js.Dec.2013.www.EBooksWorld.ir.pdf</Footnote>. 다음 표는 두 함수의 주요 특징을 비교합니다.

| 특징 | setTimeout | setInterval |
|--------|------------|-------------|
| **호출 방식** | 지정한 지연 후 한 번 실행 | 지정한 간격마다 반복 실행 |
| **반복성** | 단발 실행 | 반복 실행 |
| **취소 방법** | `clearTimeout(timeoutId)` | `clearInterval(intervalId)` |
| **타이밍 드리프트** | 상대적으로 적음 (재귀적 호출 활용 시) | 상대적으로 큼 (지연 누적으로 인한 드리프트 가능) |
| **용도** | 단발 지연 실행, 드리프트 제어가 필요한 반복 작업 | 단순 반복 작업에 적합 |
| **콜백 인자** | 함수 또는 문자열 (함수 권장) | 함수 또는 문자열 (함수 권장) |

`setTimeout`은 일회성 지연 실행에 특화되어 있으며, 반복이 필요한 경우 재귀 호출 방식을 통해 다음 실행을 동적으로 스케줄링하여 드리프트를 정밀하게 제어할 수 있습니다. 반면 `setInterval`은 고정 간격으로 콜백을 스케줄링하지만, 메인 스레드의 다른 작업으로 인해 콜백 실행이 지연될 경우 다음 간격 예약까지의 시간이 부족해져 타이밍 드리프트가 누적되기 쉽습니다.

## 4. 타이밍 드리프트 (Drift) 현상 심층 분석

타이밍 드리프트는 `setTimeout`이나 `setInterval`로 예약된 콜백 함수가 지정된 시간보다 늦게 실행되는 현상을 의미합니다<Footnote>Internal Clock Drift Estimation in Computer Clusters - Wiley Online Library, https://onlinelibrary.wiley.com/doi/10.1155/2008/583162</Footnote>. 이는 특히 `setInterval`을 사용할 때 누적되어 심각한 문제를 야기할 수 있습니다.

### 4.1. 드리프트 발생 원인

*   **이벤트 루프 혼잡**: JavaScript는 단일 스레드로 작동하므로, 콜 스택에서 장시간 실행되는 다른 스크립트(예: 복잡한 계산, 큰 데이터 처리)가 있다면 타이머 콜백은 콜 스택이 비워질 때까지 기다려야 합니다<Footnote>A comprehensive study on real world concurrency bugs in Node.js - IEEE Xplore, https://ieeexplore.ieee.org/abstract/document/8115663/</Footnote>. 이로 인해 예약된 실행 시간보다 실제 실행 시간이 늦어지게 됩니다.

*   **브라우저 최적화/스로틀링**: 웹 브라우저는 성능 및 배터리 수명 최적화를 위해 백그라운드 탭이나 비활성 상태의 탭에서 타이머의 최소 지연 시간을 클램핑(clamping, 제한)합니다<Footnote>SoK: In Search of Lost Time: A Review of JavaScript Timers in Browsers - IEEE Xplore, https://ieeexplore.ieee.org/document/9581218/</Footnote>. 예를 들어, `setTimeout(callback, 10)`이 백그라운드 탭에서는 1초 또는 그 이상으로 지연될 수 있습니다.

*   **시스템 부하**: CPU 사용률이 높거나 시스템 리소스가 부족할 때, JavaScript 엔진이 콜백을 처리하는 데 더 많은 시간이 소요될 수 있어 타이머의 정확도가 떨어집니다<Footnote>30 seconds is not enough! A study of operating system timer usage - ACM Digital Library, https://dl.acm.org/doi/abs/10.1145/1357010.1352614</Footnote>.

*   **타이머 해상도 제한**: 브라우저와 Node.js 환경 모두에서 타이머의 최소 해상도(precision)는 환경에 따라 다를 수 있으며, 이는 미세한 타이밍의 정확도를 제한할 수 있습니다. 보안상의 이유로 브라우저가 타이머의 정밀도를 낮추는 경우도 있습니다<Footnote>Fantastic timers and where to find them: High-resolution microarchitectural attacks in JavaScript - Springer, https://link.springer.com/chapter/10.1007/978-3-319-70972-7_13</Footnote>.

### 4.2. 드리프트 누적 메커니즘 (setInterval 중심)

`setInterval`은 각 콜백의 실행 완료 여부와 상관없이 지정된 간격마다 반복적으로 새로운 콜백을 태스크 큐에 추가하려고 시도합니다<Footnote>Periodic timers revisited: The real-time embedded system perspective - Elsevier, https://linkinghub.elsevier.com/retrieve/pii/S0045790611000309</Footnote>. 예를 들어, `setInterval(callback, 100)`을 설정했는데 `callback` 함수 실행에 120ms가 걸렸다면, 다음 콜백은 100ms 간격으로 예약되었지만 이전 콜백이 아직 끝나지 않았으므로 큐에 대기하게 됩니다. 이 경우, 실제 두 콜백 사이의 간격은 120ms 이상이 되며, 이 지연이 계속해서 다음 예약에 영향을 미치면서 드리프트가 누적됩니다. 이는 중첩된 실행을 유발하고, 결과적으로 메모리 누수나 성능 저하로 이어질 수 있습니다.

`setTimeout`은 한 번의 지연 후 실행되는 단발성 특성 때문에 이러한 누적 드리프트가 발생하지 않습니다. 대신 `setTimeout`을 재귀적으로 호출하는 방식으로 반복 작업을 구현할 경우, 각 실행 시마다 다음 지연 시간을 동적으로 계산하여 이전 실행의 지연을 보정할 수 있으므로, 누적 드리프트 없이 더 정확한 타이밍 제어가 가능합니다.

### 4.3. 환경별 드리프트 특성 (브라우저, Node.js, 모바일)

*   **브라우저 환경**: 브라우저는 UI 렌더링 스레드를 최적화하고 사용자 입력에 반응하기 위해 타이머 동작을 조절합니다. 백그라운드 탭에서의 스로틀링은 타이머의 정확도를 크게 떨어뜨릴 수 있으며, 애니메이션과 같은 시각적 피드백이 중요한 경우 `requestAnimationFrame`과 같은 대안이 권장됩니다<Footnote>Games and Animations - eCampus Ontario Pressbooks, https://ecampusontario.pressbooks.pub/webdev/chapter/games-and-animations/</Footnote>.

*   **Node.js 환경**: Node.js는 서버 환경에서 실행되므로 브라우저와 같은 UI 스레드 제약은 적지만, 여전히 이벤트 루프 블로킹이나 CPU 부하에 의해 드리프트가 발생할 수 있습니다. 특히 대규모 서비스에서는 이벤트 루프의 효율적인 관리가 타이머의 정확성에 결정적인 영향을 미칩니다<Footnote>Efficient dynamic analysis for Node.js - ACM Digital Library, https://dl.acm.org/doi/10.1145/3178372.3179527</Footnote>.

*   **모바일 환경**: 모바일 기기는 배터리 수명과 리소스 제약이 더 크기 때문에, 타이머 동작이 더욱 가변적일 수 있습니다. 운영체제의 전력 관리 정책이나 앱의 백그라운드 상태 진입 시 타이머의 정확도가 크게 저하될 수 있습니다.

실험적 연구와 벤치마크는 이러한 환경적 요인들이 `setTimeout`과 `setInterval`의 타이밍 정확도에 미치는 영향을 확인했으며, 특히 정확한 주기적 실행이 필요한 경우 `setInterval` 대신 재귀적 `setTimeout` 사용을 통해 드리프트 누적을 완화해야 함을 강조합니다<Footnote>Drift correction for the software-based clock synchronization on controller area network - IEEE Xplore, https://ieeexplore.ieee.org/abstract/document/9219676/</Footnote>.

<IntervalDriftChart />

위 그래프는 각 틱에서의 드리프트(실제 시각 - 기대 시각, ms)를 선으로 보여줍니다. 환경(Chromium/Firefox/Safari/Node), 간격(ms), 틱 수를 조절해보세요.

## 5. 드리프트 최소화를 위한 실전 활용 패턴 및 해결 전략

타이밍 드리프트는 많은 애플리케이션에서 예측 불가능한 동작이나 성능 저하를 초래할 수 있으므로, 이를 최소화하기 위한 실전 패턴과 보정 알고리즘을 적용하는 것이 중요합니다<Footnote>Avoiding Fake Boundaries in Set Interval Computing - Semantic Scholar, https://www.semanticscholar.org/paper/7eea6444e27d27479ba40dacc882cb0e591a9dc0</Footnote>.

### 5.1. 재귀적 setTimeout 패턴

가장 효과적인 드리프트 방지 전략은 `setInterval` 대신 `setTimeout`을 재귀적으로 호출하는 것입니다. 이 패턴은 각 콜백 실행이 완료된 후에 다음 콜백을 스케줄링하므로, 이전 실행의 지연 시간을 고려하여 다음 지연 시간을 동적으로 조절할 수 있습니다<Footnote>A Sense of Time for JavaScript and Node.js: First-Class Timeouts as a Cure for Event Handler Poisoning - USENIX, https://www.usenix.org/conference/usenixsecurity18/presentation/davis</Footnote>.

```javascript
(function loop() {
  const startTime = new Date().getTime();
  // 수행할 작업
  console.log("Task executed at", new Date().toLocaleTimeString());

  const endTime = new Date().getTime();
  const executionTime = endTime - startTime;
  const delay = Math.max(0, 1000 - executionTime); // 목표 간격 1000ms

  setTimeout(loop, delay);
})();
```

이 예제에서, `loop` 함수는 실행 시작 시간을 기록하고 작업을 수행한 다음, 작업 완료 시간을 기준으로 다음 `setTimeout` 호출까지의 지연 시간을 계산합니다. 이를 통해 작업 실행에 소요된 시간을 보정하여 다음 콜백이 대략적인 목표 간격에 맞춰 실행되도록 유도하며, 누적 드리프트를 효과적으로 방지합니다.

### 5.2. 보정 알고리즘의 적용

재귀적 `setTimeout` 패턴 내에서 보정 알고리즘을 더욱 정교하게 구현할 수 있습니다.

*   **동적 지연 시간 조절**: 단순히 고정된 지연 시간(예: 1000ms)을 사용하는 대신, `(목표 시간 - 현재 시간)`을 계산하여 다음 `setTimeout`의 지연 시간으로 설정합니다.

*   **오차 누적 방지**: 여러 번의 실행에 걸쳐 발생한 미세한 오차를 추적하고, 주기적으로 오차를 초기화하거나 조정하여 장기적인 드리프트 누적을 방지합니다<Footnote>Interval timing - Nature, https://www.nature.com/articles/nrn1764-c1</Footnote>.

*   **로드 감지**: Node.js 환경에서는 이벤트 루프의 상태나 시스템 부하를 감지하여 타이머 간격을 동적으로 조절하는 고급 스케줄링 전략을 고려할 수 있습니다.

### 5.3. Node.js 환경에서의 고려사항

Node.js는 이벤트 루프를 기반으로 비동기 작업을 처리하므로, `setTimeout`과 `setInterval`의 동작은 이벤트 루프의 다른 단계(I/O 콜백, poll, check 등)와 상호작용합니다. 따라서 서버 애플리케이션에서 타이머를 사용할 때는 장시간 실행되는 I/O 작업이나 CPU 집약적인 연산이 이벤트 루프를 블로킹하지 않도록 주의해야 합니다<Footnote>Assessing the security of Node.js platform - IEEE Xplore, https://ieeexplore.ieee.org/abstract/document/6470829/</Footnote>. 비결정성(non-determinism)을 유발할 수 있는 타이머 사용을 관리하고, 부하가 높은 상황에서도 안정적인 타이머 실행을 위한 전략을 마련해야 합니다.

### 5.4. 웹 브라우저 환경에서의 고려사항

브라우저는 사용자 경험을 위해 타이머 동작에 제약을 두므로, 특히 UI와 관련된 애니메이션 작업에는 `requestAnimationFrame`과 같은 대체 기술을 우선적으로 고려해야 합니다. 일반적인 주기적 작업의 경우, 재귀적 `setTimeout` 패턴을 사용하되, 백그라운드 탭에서의 성능 저하 가능성을 인지하고 중요한 작업은 서버 측에서 처리하거나 Web Workers를 활용하여 메인 스레드의 부하를 줄이는 방법을 모색할 수 있습니다<Footnote>A Parallelization of Interactive Animation Software with Web Workers - IEEE Xplore, https://ieeexplore.ieee.org/document/6685442/</Footnote>.

## 6. 올바른 사용 사례와 잘못된 사용 사례

`setTimeout`과 `setInterval`을 효과적이고 안전하게 사용하려면 각각의 강점과 약점을 명확히 이해하고 적절한 사용 사례를 구분해야 합니다<Footnote>Common Pitfalls - Springer, https://link.springer.com/chapter/10.1007/978-981-13-7747-1_26</Footnote>.

### 6.1. setTimeout의 올바른 사용 사례

*   **단발성 지연 실행**: 특정 시간 후에 단 한 번 코드를 실행해야 할 때 가장 적합합니다. 예를 들어, 사용자 입력 후 일정 시간 뒤에 검색을 시작하는 디바운싱(debouncing) 기능이나, 경고 메시지를 잠시 표시한 후 사라지게 하는 기능 등이 있습니다<Footnote>Applying Timeout Effectively - Sage Publications, https://sk.sagepub.com/book/mono/difficult-behavior-in-early-childhood/chpt/applying-timeout-effectively</Footnote>.

*   **정밀한 주기적 작업 (재귀 호출)**: 타이밍 드리프트에 민감한 주기적 작업을 구현할 때 재귀적 `setTimeout` 패턴이 권장됩니다. 이는 게임 루프, 커스텀 애니메이션, 실시간 데이터 동기화 등 높은 정확도를 요구하는 시나리오에 유용합니다. 각 실행 후 다음 실행까지의 지연 시간을 동적으로 계산하여 오차를 보정할 수 있기 때문입니다.

### 6.2. setInterval의 올바른 사용 사례

*   **단순 반복 작업**: 타이밍 정확도가 매우 중요하지 않고, 콜백 함수의 실행 시간이 짧으며, 드리프트가 크게 문제되지 않는 단순 반복 작업에 `setInterval`이 편리합니다<Footnote>setInterval (): Time-Based Readings of Kinetic Poetry - University of Bergen, https://bora.uib.no/bora-xmlui/handle/1956/17267</Footnote>. 예를 들어, 시계를 업데이트하거나, 서버에 간단한 핑(ping)을 보내는 등의 작업에 활용될 수 있습니다.

### 6.3. 잘못된 사용 사례 및 문제점

*   **setInterval의 중첩 호출 및 성능 저하**: `setInterval` 콜백 함수의 실행 시간이 지정된 간격보다 길어지면, 이전 콜백이 완료되기 전에 다음 콜백이 큐에 추가될 수 있습니다. 이는 중첩된 실행을 유발하고, 콜 스택에 콜백이 쌓이면서 메모리 누수, CPU 과부하, 애플리케이션 성능 저하를 초래할 수 있습니다<Footnote>Making javascript better by making it even slower - IEEE Xplore, https://ieeexplore.ieee.org/abstract/document/6730750/</Footnote>.

*   **타이머 ID 관리 부재로 인한 메모리 누수**: `setTimeout` 또는 `setInterval`을 호출한 후 반환된 타이머 ID를 저장하지 않거나, 타이머가 더 이상 필요 없을 때 `clearTimeout()` 또는 `clearInterval()`을 호출하지 않으면, 콜백 함수가 계속해서 실행되거나 참조를 유지하여 메모리 누수를 유발할 수 있습니다. 특히 싱글 페이지 애플리케이션(SPA)에서 컴포넌트가 언마운트될 때 타이머를 정리하지 않으면 문제가 발생하기 쉽습니다.

*   **문자열 인자 사용**: `setTimeout('someCode()', delay)`와 같이 첫 번째 인자로 문자열 형태의 코드를 전달하는 것은 `eval()`과 유사하게 동작하여 코드 인젝션(code injection) 공격에 취약할 수 있습니다<Footnote>Securing timeout instructions in web applications - IEEE Xplore, https://ieeexplore.ieee.org/abstract/document/5230485/</Footnote>. 항상 함수 참조를 사용하는 것이 권장됩니다.

*   **DoS 공격 및 타이밍 공격**: 악의적인 사용자는 `setTimeout`과 `setInterval`을 남용하여 과도한 작업을 예약하거나, 매우 짧은 간격으로 타이머를 반복 호출하여 이벤트 루프를 블로킹시키고 CPU를 소모시켜 DoS(서비스 거부) 공격을 수행할 수 있습니다<Footnote>ConScript: Specifying and enforcing fine-grained security policies for JavaScript in the browser - IEEE Xplore, https://ieeexplore.ieee.org/abstract/document/5504806/</Footnote>. 또한, 타이머의 미세한 시간 차이를 측정하여 민감한 정보를 유추하는 타이밍 측면 채널 공격에 활용될 수 있으며, 브라우저는 이에 대응하여 타이머 해상도를 제한하는 등의 조치를 취하고 있습니다<Footnote>GUARDIA: specification and enforcement of javascript security policies without VM modifications - ACM Digital Library, https://dl.acm.org/doi/abs/10.1145/3237009.3237025</Footnote>.

## 7. 대체 기술 및 미래 동향

`setTimeout`과 `setInterval`은 여전히 유용하지만, 특정 시나리오에서는 더 효율적이고 정밀하며 안전한 대체 기술들이 존재하며, JavaScript 타이머의 미래 동향은 이러한 대안과 표준화 논의에 초점을 맞추고 있습니다.

### 7.1. 주요 대체 기술

*   **requestAnimationFrame (rAF)**: 브라우저 API로, 애니메이션을 위해 최적화되어 있습니다<Footnote>Approaches towards the Comparison and Utilization of JavaScript Animation Libraries - Semantic Scholar, https://www.semanticscholar.org/paper/d442ec388e9838bba2d5802dfa1e1a2ffe94f898</Footnote>. 브라우저의 화면 재구성(repaint) 주기에 맞춰 콜백을 실행하므로, 가장 부드러운 애니메이션을 제공하며 비활성 탭에서는 자동으로 일시 중지되어 리소스 소모를 줄입니다. 일반적인 타이머보다는 UI 애니메이션에 특화되어 있습니다.

*   **Web Workers**: JavaScript 코드를 메인 UI 스레드와 독립적인 백그라운드 스레드에서 실행할 수 있게 해주는 기술입니다. CPU 집약적인 계산이나 대용량 데이터 처리 작업을 웹 워커로 오프로드하여 메인 스레드의 반응성을 유지할 수 있습니다. 웹 워커 내에서도 `setTimeout` 및 `setInterval`을 사용하여 독립적인 타이머를 관리할 수 있습니다<Footnote>Modeling the HTML DOM and browser API in static analysis of JavaScript web applications - ACM Digital Library, https://dl.acm.org/doi/abs/10.1145/2025113.2025125</Footnote>.

*   **타이머 라이브러리**: `lodash.debounce`, `rxjs`의 스케줄러 등 JavaScript 생태계에는 `setTimeout`과 `setInterval`의 기능을 확장하고 개선한 다양한 라이브러리들이 존재합니다. 이들은 더 높은 수준의 추상화, 드리프트 보정, 일시 중지/재개, 오류 처리 등의 고급 기능을 제공하여 복잡한 타이밍 로직을 더 쉽게 구현할 수 있도록 돕습니다.

*   **Web Audio API**: 오디오 관련 작업에서는 매우 정밀한 타이밍이 필요하며, `setTimeout`과 `setInterval`의 부정확성으로는 감당하기 어렵습니다. `Web Audio API`는 고해상도 타이밍을 제공하여 정확한 오디오 스케줄링을 가능하게 합니다<Footnote>Alternatives to Lookahead Audio Scheduling - Semantic Scholar, https://www.semanticscholar.org/paper/4760eee36caba54d3e0a5027ffd7d21550b157e4</Footnote>.

### 7.2. 표준화 논의 및 미래 동향

JavaScript 언어 사양을 담당하는 **TC39(Technical Committee 39)**는 ECMAScript 표준의 진화를 주도하며, 웹 표준을 다루는 **WHATWG**는 HTML과 웹 API 영역에서 `setTimeout` 및 `setInterval`과 관련된 동작 사양의 일관성과 효율성을 위해 협력하고 있습니다<Footnote>Optimal Language Design is Hard: A Case Study in ECMAScript (JavaScript) Standardization - Semantic Scholar, https://www.semanticscholar.org/paper/c9493bd79b18b893f93638d4c0d866c8543daff7</Footnote>.

미래에는 JavaScript 타이머의 신뢰성과 보안, 실시간성을 향상시키기 위한 다양한 논의와 제안이 활발히 이루어질 것으로 예상됩니다.

*   **결정론적 타이밍**: IoT(사물 인터넷)와 같이 시간 동기화가 중요한 환경에서는 JavaScript의 타이머에 더 결정론적인 시간 의미를 부여하려는 시도가 있습니다<Footnote>Deterministic timing for the industrial internet of things - IEEE Xplore, https://ieeexplore.ieee.org/abstract/document/8539099/</Footnote><Footnote>A JavaScript extension providing deterministic temporal semantics for the Internet of Things - UC Berkeley, https://www2.eecs.berkeley.edu/Pubs/TechRpts/2017/EECS-2017-136.pdf</Footnote>.

*   **보안 강화**: 타이밍 공격에 대한 지속적인 대응책 마련과 타이머 함수의 오용 방지를 위한 보안 정책 강화 논의가 진행 중입니다<Footnote>Reining in the web with content security policy - ACM Digital Library, https://dl.acm.org/doi/abs/10.1145/1772690.1772784</Footnote><Footnote>Static detection of user-specified security vulnerabilities in client-side javascript - ACM Digital Library, https://dl.acm.org/doi/abs/10.1145/2993600.2993612</Footnote>.

*   **고정밀 타이머 API**: 기존 `setTimeout`과 `setInterval`의 한계를 극복하고 더 정확한 타이밍 제어를 위한 새로운 API에 대한 제안이 나올 수 있습니다. 예를 들어, W3C Multi-device Timing Community Group에서는 `setTimeout`을 기반으로 한 정밀 타이밍을 보장하는 새로운 프로그래밍 모델(`timingsrc`)과 타이밍 객체를 표준화하려고 제안하고 있습니다<Footnote>Data-independent sequencing with the timing object: a JavaScript sequencer for single-device and multi-device web media - ACM Digital Library, https://dl.acm.org/doi/10.1145/2910017.2910614</Footnote>.

*   **개발자 인식 및 교육**: 타이머 드리프트와 같은 문제점, 그리고 `requestAnimationFrame`이나 Web Workers와 같은 대안의 중요성에 대한 개발자들의 인식이 높아질수록, 더욱 견고하고 효율적인 웹 애플리케이션 개발이 가능해질 것입니다<Footnote>The Future of Web Development: Exploring JavaScript's Role in Web3 and Decentralized Apps - Semantic Scholar, https://www.semanticscholar.org/paper/20e7190e7377610e08d2db7e2a325e7c6f687d61</Footnote>.

결론적으로, `setTimeout`과 `setInterval`은 JavaScript 개발의 근간을 이루는 중요한 도구이지만, 이들의 비동기적 특성과 드리프트 현상에 대한 깊은 이해 없이는 예측 불가능한 버그와 성능 문제를 야기할 수 있습니다<Footnote>Pitfalls in the automated strengthening of passwords - ACM Digital Library, https://dl.acm.org/doi/abs/10.1145/2523649.2523651</Footnote>. 각 함수의 장단점을 명확히 인지하고, 재귀적 `setTimeout`과 같은 드리프트 보정 패턴, 그리고 `requestAnimationFrame`이나 Web Workers 같은 대체 기술을 적재적소에 활용하는 것이 최신 웹 및 서버 애플리케이션 개발에서 요구되는 핵심 역량이라 할 수 있습니다. 지속적인 표준화 논의와 새로운 기술 제안들은 JavaScript 타이머의 미래를 더욱 정밀하고 안전하게 만들어 나갈 것입니다<Footnote>A Faithful Description of ECMAScript Algorithms - ACM Digital Library, https://dl.acm.org/doi/10.1145/3551357.3551381</Footnote>.


<Footnotes />
