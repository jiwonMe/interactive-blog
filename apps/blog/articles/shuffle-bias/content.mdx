---
title: 'Shuffle Algorithm Bias 시각화하기'
date: '2025-11-21'
description: '랜덤 셔플 알고리즘의 편향성을 매트릭스 다이어그램으로 시각화하고 비교합니다.'
author: 'JIWON'
tags: ['algorithm', 'visualization', 'd3', 'random']
---

# Shuffle Algorithm Bias 시각화하기

Mike Bostock의 Will It Shuffle?<Footnote>https://bost.ocks.org/mike/shuffle/compare.html</Footnote> 글은 셔플 알고리즘의 편향성을 시각적으로 아주 잘 설명한 명작입니다. 오늘은 D3.js와 React를 사용하여 이 시각화를 직접 구현해보고, 왜 잘못된 셔플 알고리즘이 문제가 되는지, 그리고 Fisher-Yates 알고리즘이 왜 공정한지 직접 눈으로 확인해보겠습니다.

## 셔플의 공정성 (Fairness)

완벽한 셔플 알고리즘이라면, 원본 배열의 모든 요소가 셔플 후의 모든 위치에 갈 확률이 동일해야 합니다. 즉, $N$개의 요소가 있다면 특정 요소가 특정 위치에 있을 확률은 정확히 $1/N$이어야 합니다.

만약 이 확률이 균일하지 않다면, 그 알고리즘은 **편향(Bias)**되어 있다고 말합니다.

## 시각화: Matrix Diagram

아래의 인터랙티브 시각화 도구는 수천 번의 셔플을 수행하고 그 결과를 집계하여 보여줍니다.

- **행 (Row, $i$)**: 셔플 전 원래 위치
- **열 (Column, $j$)**: 셔플 후 이동한 위치
- **색상**:
  - <span style={{color: "#e66101", fontWeight: "bold"}}>주황색</span>: 기대값보다 더 자주 등장 (Positive Bias)
  - <span style={{color: "#f7f7f7", backgroundColor: "#333", padding: "0 4px"}}>흰색</span>: 기대값만큼 등장 (Unbiased)
  - <span style={{color: "#5e3c99", fontWeight: "bold"}}>보라색</span>: 기대값보다 덜 등장 (Negative Bias)

<ShuffleVisualizer />

### 1. Random Comparator (나쁜 예)

흔히 저지르는 실수 중 하나는 `array.sort(() => Math.random() - 0.5)`와 같은 코드를 사용하는 것입니다.

```javascript
// ❌ 절대로 사용하지 마세요!
function randomComparatorShuffle(array) {
  return array.sort(() => Math.random() - 0.5);
}
```

위의 시각화에서 **Random Comparator**를 선택하고 시뮬레이션을 돌려보세요. 대각선이나 특정 패턴이 강하게 나타나는 것을 볼 수 있습니다. 이는 요소들이 충분히 섞이지 않거나 특정 위치로 쏠린다는 것을 의미합니다.

#### Random Comparator의 수학적 분석

Random Comparator가 왜 실패하는지 수학적으로 분석해보겠습니다.

##### 문제 1: 비교 횟수의 부족

대부분의 정렬 알고리즘(예: QuickSort, MergeSort)은 $O(n \log n)$ 번의 비교를 수행합니다. $N$ 개 요소의 완벽한 셔플을 위해서는 $N!$ 가지의 순열 중 하나를 균등하게 선택해야 합니다.

엔트로피 관점에서, $N!$ 가지 순열을 구분하기 위해 필요한 정보량은:

$$
\log_2(N!) \approx N \log_2 N - N \log_2 e
$$

하지만 $O(n \log n)$ 번의 비교로 얻을 수 있는 정보는 최대 $n \log n$ 비트입니다. 예를 들어 $N = 10$ 일 때:

- 필요한 정보량: $\log_2(10!) \approx 21.8$ 비트
- sort 비교 횟수: $\approx 10 \log_2 10 \approx 33$ 회

언뜻 보면 충분해 보이지만, 문제는 비교 함수가 **일관성이 없다**는 것입니다.

##### 문제 2: 비교 함수의 비일관성

정렬 알고리즘은 비교 함수가 다음 속성을 만족한다고 가정합니다:

1. **반사성 (Reflexivity)**: $a = a$ 이면 $\text{compare}(a, a) = 0$
2. **반대칭성 (Antisymmetry)**: $\text{compare}(a, b) < 0$ 이면 $\text{compare}(b, a) > 0$
3. **추이성 (Transitivity)**: $a < b$ 이고 $b < c$ 이면 $a < c$

하지만 `() => Math.random() - 0.5` 는 이 속성들을 만족하지 않습니다. 특히 추이성이 깨집니다:

- 첫 번째 비교: $a < b$ (확률 0.5)
- 두 번째 비교: $b < c$ (확률 0.5)
- 세 번째 비교: $c < a$ (확률 0.5) ← 논리적 모순!

이러한 비일관성 때문에 정렬 알고리즘의 동작이 예측 불가능해지고, 구현에 크게 의존하게 됩니다.

##### 문제 3: V8 엔진의 구체적인 예시

V8 JavaScript 엔진(Chrome, Node.js)은 배열 크기에 따라 다른 정렬 알고리즘을 사용합니다:

- 작은 배열 ($n < 10$): Insertion Sort
- 큰 배열 ($n \geq 10$): TimSort (Merge Sort + Insertion Sort의 하이브리드)

TimSort는 "run"이라는 이미 정렬된 부분 수열을 찾아서 병합합니다. Random comparator를 사용하면 원본 배열의 순서가 남아있는 "run"들이 부분적으로 보존되어, 원래 위치 근처에 머물 확률이 높아집니다. 이것이 대각선 패턴이 나타나는 이유입니다.

##### 실험적 증거

$N = 10$ 인 배열에서 Random Comparator를 사용할 때, 이론적으로 각 순열의 확률은 $\frac{1}{10!} \approx 0.0000275\%$ 여야 합니다. 하지만 실제로는:

- 가장 자주 나타나는 순열: $\approx 0.00005\%$ (약 2배 높음)
- 가장 드물게 나타나는 순열: $\approx 0.00001\%$ (약 2배 낮음)
- 일부 순열은 아예 생성되지 않을 수도 있음

이는 명백한 편향을 나타냅니다.

### 2. Naive Swap (나쁜 예)

또 다른 실수는 "모든 요소에 대해 임의의 위치와 교환"하는 방식입니다.

```javascript
// ❌ 미묘하게 편향됩니다.
function naiveSwapShuffle(array) {
  const n = array.length;
  for (let i = 0; i < n; i++) {
    const j = Math.floor(Math.random() * n); // 0부터 n-1까지 아무거나
    swap(array, i, j);
  }
}
```

언뜻 보면 공정해 보이지만, 이 방식은 $N^N$가지의 경우의 수를 만들어냅니다. 하지만 $N$개의 요소를 나열하는 방법은 $N!$가지입니다. $N^N$은 $N!$로 나누어 떨어지지 않으므로, 필연적으로 어떤 결과는 다른 결과보다 더 많이 나올 수밖에 없습니다.

시각화에서 **Naive Swap**을 선택해보세요. 얼핏 보면 괜찮아 보이지만, 반복 횟수가 많아지면 미세한 편향이 드러납니다.

### 3. Fisher-Yates Shuffle (좋은 예)

가장 올바른 방법은 Fisher-Yates (또는 Knuth) 셔플입니다.

```javascript
// ✅ 올바른 셔플 알고리즘
function fisherYatesShuffle(array) {
  let m = array.length, t, i;
  while (m) {
    i = Math.floor(Math.random() * m--); // 남아있는 요소 중에서 선택
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }
  return array;
}
```

이 알고리즘은 수학적으로 완벽하게 공정한 셔플을 보장합니다. 시각화에서 **Fisher-Yates**를 선택하면 전체 매트릭스가 균일한 노이즈(회색)로 채워지는 것을 확인할 수 있습니다.

### Fisher-Yates 알고리즘의 수학적 증명

Fisher-Yates 알고리즘이 왜 수학적으로 완벽하게 균등한 셔플을 보장하는지 귀납법으로 증명할 수 있습니다.

#### 목표

$N$ 개의 요소를 가진 배열이 있을 때, Fisher-Yates 알고리즘을 적용하면 $N!$ 개의 모든 가능한 순열(permutation)이 정확히 $\frac{1}{N!}$ 의 확률로 생성됨을 보이고자 합니다.

#### 알고리즘 재정의

Fisher-Yates 알고리즘은 다음과 같이 동작합니다:

- **단계 $k$ ($k = N, N-1, \ldots, 2, 1$)**:
  - 인덱스 $0$부터 $k-1$까지 중에서 무작위로 인덱스 $i$를 선택 (확률 $\frac{1}{k}$)
  - 인덱스 $i$의 요소와 인덱스 $k-1$의 요소를 교환

#### 귀납법에 의한 증명

**기저 사례 (Base Case)**: $N = 1$

배열에 요소가 1개만 있을 때, 가능한 순열은 1개이고 확률은 $\frac{1}{1!} = 1$ 입니다. 자명하게 성립합니다.

**귀납 가정 (Inductive Hypothesis)**

$N = k-1$ 일 때, Fisher-Yates 알고리즘이 모든 $(k-1)!$ 개의 순열을 각각 $\frac{1}{(k-1)!}$ 의 확률로 생성한다고 가정합니다.

**귀납 단계 (Inductive Step)**: $N = k$

$k$ 개의 요소를 가진 배열에 대해 Fisher-Yates 알고리즘을 적용할 때:

1. **첫 번째 단계**: 마지막 위치 (인덱스 $k-1$)에 올 요소를 선택합니다.
   - 각 요소가 마지막 위치에 올 확률: $\frac{1}{k}$

2. **나머지 단계**: 처음 $k-1$ 개의 요소에 대해 알고리즘을 재귀적으로 적용합니다.
   - 귀납 가정에 의해, 이 $k-1$ 개 요소의 모든 순열은 각각 $\frac{1}{(k-1)!}$ 의 확률로 생성됩니다.

특정 순열 $P$가 생성될 확률을 계산하면:

$$
P(\text{순열 } P) = P(\text{특정 요소가 마지막 위치}) \times P(\text{나머지 요소들의 순열})
$$

$$
= \frac{1}{k} \times \frac{1}{(k-1)!} = \frac{1}{k!}
$$

따라서 $N = k$ 일 때도 모든 $k!$ 개의 순열이 각각 $\frac{1}{k!}$ 의 확률로 생성됩니다.

#### 각 위치의 확률 계산

특정 요소 $e$가 특정 위치 $j$에 올 확률도 계산할 수 있습니다:

$$
P(\text{요소 } e \text{가 위치 } j \text{에 위치}) = \sum_{\text{모든 순열 } P} P(P) \times \mathbb{1}_{e \in \text{위치 } j}
$$

여기서 $\mathbb{1}_{e \in \text{위치 } j}$는 순열 $P$에서 요소 $e$가 위치 $j$에 있으면 1, 아니면 0입니다.

요소 $e$ 가 위치 $j$ 에 고정되어 있을 때, 나머지 $N-1$ 개 요소의 순열은 $(N-1)!$ 가지입니다. 각 순열의 확률이 $\frac{1}{N!}$ 이므로:

$$
P(\text{요소 } e \text{가 위치 } j \text{에 위치}) = (N-1)! \times \frac{1}{N!} = \frac{1}{N}
$$

이는 모든 요소가 모든 위치에 균등한 확률 $\frac{1}{N}$로 배치됨을 의미합니다.

#### 왜 Naive Swap은 실패하는가?

비교를 위해, Naive Swap 알고리즘은 각 요소 $i$ 에 대해 $0$ 부터 $N-1$ 까지 중 임의의 인덱스 $j$ 를 선택하여 교환합니다. 이 경우:

- 총 선택의 경우의 수: $N^N$
- 가능한 순열의 수: $N!$

$N^N$ 이 $N!$ 로 나누어떨어지지 않기 때문에 (예: $3^3 = 27$, $3! = 6$), 어떤 순열은 다른 순열보다 더 자주 나타나게 됩니다. 예를 들어, $N=3$ 일 때 어떤 순열은 $\frac{5}{27}$, 어떤 순열은 $\frac{4}{27}$ 의 확률을 갖게 되어 균등하지 않습니다.

#### 결론

Fisher-Yates 알고리즘은 각 단계에서 **아직 선택되지 않은 요소들 중에서만** 선택하기 때문에 정확히 $N!$ 가지 경로를 만들어내며, 각 경로가 동등한 확률 $\frac{1}{N!}$ 을 갖습니다. 이것이 수학적으로 완벽하게 균등한 셔플을 보장하는 이유입니다.

## 결론

알고리즘의 아주 작은 차이가 데이터의 분포에 큰 영향을 미칠 수 있습니다. 특히 무작위성이 중요한 게임이나 암호화, 데이터 샘플링에서는 반드시 검증된 알고리즘(Fisher-Yates)을 사용해야 합니다.

<Footnotes />